// Generated by CoffeeScript 1.6.2
var ConnectAttack, STATUS_BANNED, STATUS_THROTTLED, exports, extend, get_ip,
  __slice = [].slice;

STATUS_THROTTLED = 429;

STATUS_BANNED = 504;

extend = function() {
  var dest, k, obj, objs, v, _i, _len;

  dest = arguments[0], objs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = objs.length; _i < _len; _i++) {
    obj = objs[_i];
    for (k in obj) {
      v = obj[k];
      dest[k] = v;
    }
  }
  return dest;
};

get_ip = function(req) {
  var ips;

  if (req.headers['x-forwarded-for'] != null) {
    ips = req.headers['x-forwarded-for'].split(/, /);
    return ips[0];
  } else {
    return req.connection.remoteAddress;
  }
};

module.exports = exports = function(rules, options) {
  var connect_attack;

  if (rules == null) {
    rules = {};
  }
  if (options == null) {
    options = {};
  }
  if (connect_attack) {
    return connect_attack;
  }
  return connect_attack = module.exports.instance = new ConnectAttack(rules, options);
};

ConnectAttack = (function() {
  function ConnectAttack(options) {
    if (options == null) {
      options = {};
    }
    this.options = extend({
      store: null,
      error_pages: null
    }, options);
    this.whitelists = {};
    this.blacklists = {};
    this.throttles = {};
    this.cache = {};
  }

  ConnectAttack.prototype.whitelist = function() {
    var d, discriminator, n, name, rules;

    rules = {};
    if (arguments.length > 1) {
      name = arguments[0];
      discriminator = arguments[1];
      rules[name] = discriminator;
    } else if (typeof arguments[0] === 'object') {
      rules = arguments;
    }
    for (n in rules) {
      d = rules[n];
      this.whitelists[n] = d;
    }
    return this;
  };

  ConnectAttack.prototype.blacklist = function() {
    var d, discriminator, n, name, rules;

    rules = {};
    if (arguments.length > 1) {
      name = arguments[0];
      discriminator = arguments[1];
      rules[name] = discriminator;
    } else if (typeof arguments[0] === 'object') {
      rules = arguments;
    }
    for (n in rules) {
      d = rules[n];
      this.blacklists[n] = d;
    }
    return this;
  };

  ConnectAttack.prototype.throttle = function() {
    var detail, discriminator, name, options, rules;

    rules = {};
    if (arguments.length === 3) {
      name = arguments[0];
      options = arguments[1];
      discriminator = arguments[2];
      rules[name] = {
        options: extend({
          limit: 5,
          period: 60,
          bantime: null
        }, options),
        discriminator: discriminator
      };
    } else if (typeof arguments[0] === 'object') {
      rules = arguments[0];
    }
    for (name in rules) {
      detail = rules[name];
      this.throttles[name] = detail;
    }
    return this;
  };

  ConnectAttack.prototype.check = function(req, res, next) {
    this.stats = {
      count: 0,
      expiring: null,
      throttled: false,
      banned: false
    };
    if (this.whilelisted(req)) {
      return next();
    } else if (this.blacklisted(req)) {
      return this.blacklisted_response(req, res, next);
    } else if (this.throttled(req)) {
      return this.throttled_response(req, res, next);
    } else {
      return next();
    }
  };

  ConnectAttack.prototype.middleware = function() {
    var _this = this;

    return function(req, res, next) {
      req.ip = get_ip(req);
      return _this.check(req, res, next);
    };
  };

  ConnectAttack.prototype.whilelisted = function(req) {
    var discriminator, matched, name, _ref;

    _ref = this.whitelists;
    for (name in _ref) {
      discriminator = _ref[name];
      matched = discriminator(req);
      if (matched) {
        return matched;
      }
    }
  };

  ConnectAttack.prototype.blacklisted = function(req) {
    var discriminator, matched, name, _ref;

    _ref = this.blacklists;
    for (name in _ref) {
      discriminator = _ref[name];
      matched = discriminator(req);
      if (matched) {
        return matched;
      }
    }
  };

  ConnectAttack.prototype.throttled = function(req) {
    var detail, matched, name, _ref;

    _ref = this.throttles;
    for (name in _ref) {
      detail = _ref[name];
      matched = detail.discriminator(req);
      if (!matched) {
        continue;
      }
      this.count(req, name, detail.options);
      if (this.stats.throttled) {
        return matched;
      }
    }
  };

  ConnectAttack.prototype.blacklisted_response = function(req, res) {
    res.statusCode = STATUS_BANNED;
    if (!this.options.error_pages[res.statusCode]) {
      return res.end();
    }
    res.write(this.options.error_pages[res.statusCode]);
    return res.end();
  };

  ConnectAttack.prototype.throttled_response = function(req, res) {
    if (this.stats.banned) {
      console.log("Client " + req.ip + " banned from " + req.url);
      res.statusCode = STATUS_BANNED;
    } else {
      console.log("Client " + req.ip + " reaches rate limit on " + req.url);
      res.statusCode = STATUS_THROTTLED;
    }
    if (!this.options.error_pages[res.statusCode]) {
      return res.end();
    }
    res.write(this.options.error_pages[res.statusCode]);
    return res.end();
  };

  ConnectAttack.prototype.count = function(req, name, options) {
    var counter_key, expiring_key, now;

    counter_key = "" + req.ip + "|" + name + "|" + req.url + "|counter";
    expiring_key = "" + req.ip + "|" + name + "|" + req.url + "|expiring";
    if (this.options.store == null) {
      now = Math.round(new Date().getTime() / 1000);
      if (!((this.cache[counter_key] != null) && this.cache[expiring_key] > now)) {
        this.stats.count = 1;
        this.stats.expiring = now + options.period;
        this.cache[counter_key] = this.stats.count;
        this.cache[expiring_key] = this.stats.expiring;
        return this.stats;
      }
      this.cache[counter_key] += 1;
      if (this.cache[counter_key] > options.limit) {
        this.stats.throttled = true;
        if (options.bantime > 0) {
          this.cache[expiring_key] + options.bantime;
          this.stats.banned = true;
        }
      }
      this.stats.count = this.cache[counter_key];
      this.stats.expiring = this.cache[expiring_key];
    }
    return this.stats;
  };

  ConnectAttack.prototype.clear_cache = function() {
    return this.cache = {};
  };

  return ConnectAttack;

})();
